{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { initialState } from './programReducer';\nfunction workoutReducer(state = initialState, action) {\n  switch (action.type) {\n    //For adding a new workout to the program.\n    case 'ADD_WORKOUT':\n      // Find the highest index used in existing workout names\n      const maxIndex = state.program.workouts.reduce((max, workout) => {\n        const match = workout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      // Create a new workout with an incremented title index or use the provided name\n      const workoutTitle = action.payload.name || `Workout ${maxIndex + 1}`;\n      const newWorkout = {\n        id: uuidv4(),\n        // Ensure a unique ID for the workout\n        name: workoutTitle,\n        exercises: [],\n        active: false // Assume new workouts are initially not active unless specified\n      };\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: [...state.program.workouts, newWorkout]\n        },\n        activeWorkout: newWorkout // Optionally set the new workout as active immediately\n      };\n    //Changes to a workout that might involve renaming or perhaps changing other properties.\n    case 'UPDATE_WORKOUT':\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: state.program.workouts.map(workout => workout.id === action.payload.id ? action.payload : workout)\n        }\n      };\n    case 'DELETE_WORKOUT':\n      const workoutIndex = state.program.workouts.findIndex(workout => workout.id === action.payload);\n\n      // Prevent deleting if only one workout exists\n      if (state.program.workouts.length <= 1) {\n        return state; // Optionally handle the error as needed\n      }\n      const updatedWorkouts = state.program.workouts.filter(workout => workout.id !== action.payload);\n\n      // Determine the new active workout if necessary\n      let newActiveWorkout = null;\n      if (state.activeWorkout && state.activeWorkout.id === action.payload) {\n        if (workoutIndex === state.program.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active\n          newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last)\n          newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n        }\n      } else {\n        newActiveWorkout = state.activeWorkout;\n      }\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: updatedWorkouts\n        },\n        activeWorkout: newActiveWorkout\n      };\n    default:\n      return state;\n  }\n}\nexport { workoutReducer, initialState };","map":{"version":3,"names":["v4","uuidv4","initialState","workoutReducer","state","action","type","maxIndex","program","workouts","reduce","max","workout","match","name","index","parseInt","Math","workoutTitle","payload","newWorkout","id","exercises","active","activeWorkout","map","workoutIndex","findIndex","length","updatedWorkouts","filter","newActiveWorkout"],"sources":["/Users/mike/Documents/purple.nosync/pow/web-frontend/src/reducers/workoutReducer.js"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { initialState } from './programReducer';\n\nfunction workoutReducer(state = initialState, action) {\n  switch (action.type) {\n    //For adding a new workout to the program.\n    case 'ADD_WORKOUT':\n      // Find the highest index used in existing workout names\n      const maxIndex = state.program.workouts.reduce((max, workout) => {\n        const match = workout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      // Create a new workout with an incremented title index or use the provided name\n      const workoutTitle = action.payload.name || `Workout ${maxIndex + 1}`;\n\n      const newWorkout = {\n        id: uuidv4(), // Ensure a unique ID for the workout\n        name: workoutTitle,\n        exercises: [],\n        active: false // Assume new workouts are initially not active unless specified\n      };\n\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: [...state.program.workouts, newWorkout]\n        },\n        activeWorkout: newWorkout // Optionally set the new workout as active immediately\n      };\n    //Changes to a workout that might involve renaming or perhaps changing other properties.\n    case 'UPDATE_WORKOUT':\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: state.program.workouts.map(workout =>\n            workout.id === action.payload.id ? action.payload : workout\n          )\n        }\n      };\n\n    case 'DELETE_WORKOUT':\n      const workoutIndex = state.program.workouts.findIndex(\n        workout => workout.id === action.payload\n      );\n\n      // Prevent deleting if only one workout exists\n      if (state.program.workouts.length <= 1) {\n        return state; // Optionally handle the error as needed\n      }\n\n      const updatedWorkouts = state.program.workouts.filter(\n        workout => workout.id !== action.payload\n      );\n\n      // Determine the new active workout if necessary\n      let newActiveWorkout = null;\n      if (state.activeWorkout && state.activeWorkout.id === action.payload) {\n        if (workoutIndex === state.program.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active\n          newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last)\n          newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n        }\n      } else {\n        newActiveWorkout = state.activeWorkout;\n      }\n\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: updatedWorkouts\n        },\n        activeWorkout: newActiveWorkout\n      };\n\n    default:\n      return state;\n  }\n}\n\nexport { workoutReducer, initialState };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}