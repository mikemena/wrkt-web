{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nconst initialState = {\n  program: {\n    workouts: []\n  },\n  activeWorkout: null\n};\nfunction workoutReducer(state = initialState, action) {\n  let maxIndex;\n  switch (action.type) {\n    //For adding a new workout to the program.\n\n    case 'ADD_WORKOUT':\n      console.log('ADD_WORKOUT called from workoutReducer.js');\n      // Find the highest index used in existing workout names\n      const maxIndex = state.program.workouts.reduce((max, workout) => {\n        console.log('maxIndex called from workoutReducer.js', maxIndex);\n        const match = workout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      // Create a new workout with an incremented title index or use the provided name\n      const workoutTitle = action.payload.name || `Workout ${maxIndex + 1}`;\n      const newWorkout = {\n        id: uuidv4(),\n        // Ensure a unique ID for the workout\n        name: workoutTitle,\n        exercises: [],\n        active: false // Assume new workouts are initially not active unless specified\n      };\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: [...state.program.workouts, newWorkout]\n        },\n        activeWorkout: newWorkout // Optionally set the new workout as active immediately\n      };\n    //Changes to a workout that might involve renaming or perhaps changing other properties.\n    case 'UPDATE_WORKOUT':\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: state.program.workouts.map(workout => workout.id === action.payload.id ? action.payload : workout)\n        }\n      };\n    case 'DELETE_WORKOUT':\n      const workoutIndex = state.program.workouts.findIndex(workout => workout.id === action.payload);\n\n      // Prevent deleting if only one workout exists\n      if (state.program.workouts.length <= 1) {\n        return state; // Optionally handle the error as needed\n      }\n      const updatedWorkouts = state.program.workouts.filter(workout => workout.id !== action.payload);\n\n      // Determine the new active workout if necessary\n      let newActiveWorkout = null;\n      if (state.activeWorkout && state.activeWorkout.id === action.payload) {\n        if (workoutIndex === state.program.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active\n          newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last)\n          newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n        }\n      } else {\n        newActiveWorkout = state.activeWorkout;\n      }\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: updatedWorkouts\n        },\n        activeWorkout: newActiveWorkout\n      };\n    default:\n      return state;\n  }\n}\nexport { workoutReducer };","map":{"version":3,"names":["v4","uuidv4","initialState","program","workouts","activeWorkout","workoutReducer","state","action","maxIndex","type","console","log","reduce","max","workout","match","name","index","parseInt","Math","workoutTitle","payload","newWorkout","id","exercises","active","map","workoutIndex","findIndex","length","updatedWorkouts","filter","newActiveWorkout"],"sources":["/Users/mike/Documents/purple.nosync/pow/web-frontend/src/reducers/workoutReducer.js"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\n\nconst initialState = {\n  program: {\n    workouts: []\n  },\n  activeWorkout: null\n};\n\nfunction workoutReducer(state = initialState, action) {\n  let maxIndex;\n  switch (action.type) {\n    //For adding a new workout to the program.\n\n    case 'ADD_WORKOUT':\n      console.log('ADD_WORKOUT called from workoutReducer.js');\n      // Find the highest index used in existing workout names\n      const maxIndex = state.program.workouts.reduce((max, workout) => {\n        console.log('maxIndex called from workoutReducer.js', maxIndex);\n        const match = workout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      // Create a new workout with an incremented title index or use the provided name\n      const workoutTitle = action.payload.name || `Workout ${maxIndex + 1}`;\n\n      const newWorkout = {\n        id: uuidv4(), // Ensure a unique ID for the workout\n        name: workoutTitle,\n        exercises: [],\n        active: false // Assume new workouts are initially not active unless specified\n      };\n\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: [...state.program.workouts, newWorkout]\n        },\n        activeWorkout: newWorkout // Optionally set the new workout as active immediately\n      };\n    //Changes to a workout that might involve renaming or perhaps changing other properties.\n    case 'UPDATE_WORKOUT':\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: state.program.workouts.map(workout =>\n            workout.id === action.payload.id ? action.payload : workout\n          )\n        }\n      };\n\n    case 'DELETE_WORKOUT':\n      const workoutIndex = state.program.workouts.findIndex(\n        workout => workout.id === action.payload\n      );\n\n      // Prevent deleting if only one workout exists\n      if (state.program.workouts.length <= 1) {\n        return state; // Optionally handle the error as needed\n      }\n\n      const updatedWorkouts = state.program.workouts.filter(\n        workout => workout.id !== action.payload\n      );\n\n      // Determine the new active workout if necessary\n      let newActiveWorkout = null;\n      if (state.activeWorkout && state.activeWorkout.id === action.payload) {\n        if (workoutIndex === state.program.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active\n          newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last)\n          newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n        }\n      } else {\n        newActiveWorkout = state.activeWorkout;\n      }\n\n      return {\n        ...state,\n        program: {\n          ...state.program,\n          workouts: updatedWorkouts\n        },\n        activeWorkout: newActiveWorkout\n      };\n\n    default:\n      return state;\n  }\n}\n\nexport { workoutReducer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}