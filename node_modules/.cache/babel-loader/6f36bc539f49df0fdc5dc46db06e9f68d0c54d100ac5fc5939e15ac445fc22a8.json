{"ast":null,"code":"var _jsxFileName = \"/Users/mike/Documents/purple.nosync/pow/web-frontend/src/contexts/programContext.js\",\n  _s = $RefreshSig$();\nimport { createContext, useState, useCallback, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ProgramContext = /*#__PURE__*/createContext();\nexport const ProgramProvider = ({\n  children\n}) => {\n  _s();\n  const [program, setProgram] = useState({\n    user_id: 2,\n    // This should be set to the logged in user's ID\n    name: '',\n    program_duration: 0,\n    duration_unit: '',\n    days_per_week: 0,\n    main_goal: '',\n    workouts: [{\n      id: uuidv4(),\n      name: 'Workout 1',\n      exercises: []\n    }]\n  });\n  console.log('Program state:', program);\n  const [activeWorkoutId, setActiveWorkoutId] = useState(program.workouts[0].id);\n\n  //Save program to the database\n  const saveProgram = async NewProgram => {\n    const programData = {\n      user_id: 2,\n      // Assuming this is static or retrieved from somewhere else\n      name: program.programName,\n      program_duration: program.programDuration,\n      days_per_week: program.daysPerWeek,\n      duration_unit: program.durationUnit,\n      main_goal: program.mainGoal,\n      workouts: program.workouts.map(workout => ({\n        name: workout.name,\n        order: workout.id,\n        // Assuming `id` can serve as `order`\n        exercises: workout.exercises.map(exercise => ({\n          catalog_exercise_id: exercise.catalog_exercise_id,\n          order: exercise.order,\n          // Make sure this exists or determine how to set it\n          sets: exercise.sets || [] // Assuming `sets` exist in `exercise`, if not, you'll need to adjust\n        }))\n      }))\n    };\n\n    // console.log('Saving program from front end:', programData);\n\n    try {\n      const response = await fetch('http://localhost:9025/api/programs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(programData)\n      });\n      if (!response.ok) {\n        throw new Error('Something went wrong with saving the program');\n      }\n\n      // Assuming the backend responds with the created template, you could use it here if needed\n      // const savedTemplate = await response.json();\n    } catch (error) {\n      console.error('Failed to save the program:', error);\n      // Here, you could set an error state and display it to the user if you wish\n    }\n  };\n\n  // Functions to update the state of top-level properties of the program object\n\n  const updateProgramDetails = useCallback(details => {\n    setProgram(prev => ({\n      ...prev,\n      ...details\n    }));\n  }, []);\n\n  // Function to add a workout to the program\n\n  const addWorkout = useCallback(workout => {\n    console.log('addWorkout func in context , received workout to add:', workout);\n    const tempId = uuidv4();\n\n    // Find the highest index used in existing workout names\n    const maxIndex = program.workouts.reduce((max, currWorkout) => {\n      const match = currWorkout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n      const index = match ? parseInt(match[1], 10) : 0;\n      return Math.max(max, index);\n    }, 0);\n    const workoutTitle = `Workout ${maxIndex + 1}`;\n    const newWorkout = {\n      ...workout,\n      id: tempId,\n      name: workout.name || workoutTitle\n    };\n    setProgram(prev => ({\n      ...prev,\n      workouts: [...prev.workouts, newWorkout]\n    }));\n    setActiveWorkoutId(newWorkout.id);\n    console.log('Workouts after addWorkout:', newWorkout);\n  }, [program.workouts]);\n\n  // Function to update a workout\n\n  const updateWorkout = updatedWorkout => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => workout.id === updatedWorkout.id ? updatedWorkout : workout)\n    }));\n  };\n\n  // Function to delete a workout\n\n  const deleteWorkout = useCallback(workoutId => {\n    console.log(`Attempting to delete workout with id: ${workoutId}`);\n    setProgram(prev => {\n      let newActiveWorkoutId = prev.activeWorkoutId;\n      const workoutIndex = prev.workouts.findIndex(workout => workout.id === workoutId);\n\n      // Ensure we have more than one workout to prevent deleting the last one.\n      if (prev.workouts.length <= 1) return prev; // Or handle the error as needed.\n\n      const updatedWorkouts = prev.workouts.filter(workout => workout.id !== workoutId);\n      console.log('Workouts after deletion:', updatedWorkouts);\n\n      // If the deleted workout was the active one, update the activeWorkoutId.\n      if (newActiveWorkoutId === workoutId) {\n        if (workoutIndex === prev.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active.\n          newActiveWorkoutId = updatedWorkouts[workoutIndex - 1].id;\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last).\n          newActiveWorkoutId = updatedWorkouts[Math.max(0, workoutIndex)].id;\n        }\n      }\n\n      // Update the active workout ID in the state.\n      setActiveWorkoutId(newActiveWorkoutId);\n\n      // Return the updated program.\n      return {\n        ...prev,\n        workouts: updatedWorkouts\n      };\n    });\n  }, []);\n\n  // Function to go to the next workout\n\n  const goToNextWorkout = () => {\n    const currentIndex = program.workouts.findIndex(workout => workout.id === activeWorkoutId);\n    const nextIndex = (currentIndex + 1) % program.workouts.length;\n    setActiveWorkoutId(program.workouts[nextIndex].id);\n  };\n\n  // Function to go to the previous workout\n\n  const goToPreviousWorkout = () => {\n    const currentIndex = program.workouts.findIndex(workout => workout.id === activeWorkoutId);\n    const previousIndex = (currentIndex - 1 + program.workouts.length) % program.workouts.length;\n    setActiveWorkoutId(program.workouts[previousIndex].id);\n  };\n\n  // Function to add exercise to a specific workout\n\n  const addExercise = useCallback((workoutId, exercise) => {\n    const tempId = uuidv4();\n    setProgram(prev => {\n      const newWorkouts = prev.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          const currentExercises = Array.isArray(workout.exercises) ? workout.exercises : [];\n\n          // Add the tempId to the new exercise object\n          const newExercise = {\n            ...exercise,\n            id: tempId,\n            exerciseCatalogId: exercise.id,\n            isNew: true,\n            sets: [{\n              id: uuidv4(),\n              reps: '',\n              weight: '',\n              order: 1,\n              isNew: true\n            }]\n          };\n          // console.log('Adding exercise:', newExercise);\n\n          // Determine the next order value for the new exercise\n          const nextOrder = currentExercises.length > 0 ? Math.max(...currentExercises.map(ex => ex.order)) + 1 : 1;\n          return {\n            ...workout,\n            exercises: [...currentExercises, {\n              ...newExercise,\n              order: nextOrder\n            }]\n          };\n        }\n        return workout;\n      });\n      return {\n        ...prev,\n        workouts: newWorkouts\n      };\n    });\n  }, []);\n\n  // Function to update an exercise\n\n  const updateExercise = (workoutId, updatedExercise) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          // Found the workout that contains the exercise, now update the exercise\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => exercise.catalog_exercise_id === updatedExercise.catalog_exercise_id ? {\n              ...exercise,\n              ...updatedExercise\n            } : exercise)\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete exercise from  a specific workout\n\n  const deleteExercise = useCallback((workoutId, exerciseId) => {\n    // console.log(\n    //   `Deleting exercise. Workout ID: ${workoutId}, Exercise ID: ${exerciseId}`\n    // );\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // console.log(\n        //   `Before deletion, number of exercises: ${workout.exercises.length}`\n        // );\n\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.filter(exercise => exercise.id !== exerciseId)\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // Function to add sets to a specific exercise\n\n  const addSet = useCallback((workoutId, exerciseId, newSet) => {\n    const tempId = uuidv4();\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // Find the correct workout by its id\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the correct exercise by its catalog ID within the workout\n              if (exercise.id === exerciseId) {\n                // Add the new set with the temporary ID to the exercise's sets array\n                const currentSets = Array.isArray(exercise.sets) ? exercise.sets : [];\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const nextOrder = currentSets.length > 0 ? Math.max(...currentSets.map(set => set.order)) + 1 : 1;\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const updatedSet = {\n                  ...newSet,\n                  id: tempId,\n                  order: nextOrder,\n                  isNew: true\n                };\n                return {\n                  ...exercise,\n                  sets: [...currentSets, updatedSet]\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // useEffect(() => {\n  //   // console.log('Program state updated:', program);\n  // }, [program]); // This effect will run whenever the 'program' state changes\n\n  // Function to update a set\n\n  const updateSet = (workoutId, exerciseId, updatedSet) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                return {\n                  ...exercise,\n                  sets: exercise.sets.map(set => {\n                    // Find the matching set to update\n                    if (set.order === updatedSet.order) {\n                      return {\n                        ...set,\n                        ...updatedSet\n                      };\n                    }\n                    return set;\n                  })\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete a set\n  const deleteSet = (workoutId, exerciseId, setId) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                // Filter out the set to be deleted and renumber the remaining sets\n                const filteredAndRenumberedSets = exercise.sets.filter(set => set.id !== setId).map((set, index) => ({\n                  ...set,\n                  order: index + 1\n                })); // Assuming 'order' needs to be updated\n\n                return {\n                  ...exercise,\n                  sets: filteredAndRenumberedSets\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n  return /*#__PURE__*/_jsxDEV(ProgramContext.Provider, {\n    value: {\n      program,\n      saveProgram,\n      updateProgramDetails,\n      addWorkout,\n      updateWorkout,\n      deleteWorkout,\n      goToNextWorkout,\n      goToPreviousWorkout,\n      addExercise,\n      updateExercise,\n      deleteExercise,\n      addSet,\n      updateSet,\n      deleteSet\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 383,\n    columnNumber: 5\n  }, this);\n};\n_s(ProgramProvider, \"8Ar+BRzFNC0qxEGMaA61+fE6PJ8=\");\n_c = ProgramProvider;\nvar _c;\n$RefreshReg$(_c, \"ProgramProvider\");","map":{"version":3,"names":["createContext","useState","useCallback","useEffect","v4","uuidv4","jsxDEV","_jsxDEV","ProgramContext","ProgramProvider","children","_s","program","setProgram","user_id","name","program_duration","duration_unit","days_per_week","main_goal","workouts","id","exercises","console","log","activeWorkoutId","setActiveWorkoutId","saveProgram","NewProgram","programData","programName","programDuration","daysPerWeek","durationUnit","mainGoal","map","workout","order","exercise","catalog_exercise_id","sets","response","fetch","method","headers","body","JSON","stringify","ok","Error","error","updateProgramDetails","details","prev","addWorkout","tempId","maxIndex","reduce","max","currWorkout","match","index","parseInt","Math","workoutTitle","newWorkout","updateWorkout","updatedWorkout","prevProgram","deleteWorkout","workoutId","newActiveWorkoutId","workoutIndex","findIndex","length","updatedWorkouts","filter","goToNextWorkout","currentIndex","nextIndex","goToPreviousWorkout","previousIndex","addExercise","newWorkouts","currentExercises","Array","isArray","newExercise","exerciseCatalogId","isNew","reps","weight","nextOrder","ex","updateExercise","updatedExercise","deleteExercise","exerciseId","addSet","newSet","currentSets","set","updatedSet","updateSet","deleteSet","setId","filteredAndRenumberedSets","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/mike/Documents/purple.nosync/pow/web-frontend/src/contexts/programContext.js"],"sourcesContent":["import { createContext, useState, useCallback, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport const ProgramContext = createContext();\n\nexport const ProgramProvider = ({ children }) => {\n  const [program, setProgram] = useState({\n    user_id: 2, // This should be set to the logged in user's ID\n    name: '',\n    program_duration: 0,\n    duration_unit: '',\n    days_per_week: 0,\n    main_goal: '',\n    workouts: [{ id: uuidv4(), name: 'Workout 1', exercises: [] }]\n  });\n  console.log('Program state:', program);\n\n  const [activeWorkoutId, setActiveWorkoutId] = useState(\n    program.workouts[0].id\n  );\n\n  //Save program to the database\n  const saveProgram = async NewProgram => {\n    const programData = {\n      user_id: 2, // Assuming this is static or retrieved from somewhere else\n      name: program.programName,\n      program_duration: program.programDuration,\n      days_per_week: program.daysPerWeek,\n      duration_unit: program.durationUnit,\n      main_goal: program.mainGoal,\n      workouts: program.workouts.map(workout => ({\n        name: workout.name,\n        order: workout.id, // Assuming `id` can serve as `order`\n        exercises: workout.exercises.map(exercise => ({\n          catalog_exercise_id: exercise.catalog_exercise_id,\n          order: exercise.order, // Make sure this exists or determine how to set it\n          sets: exercise.sets || [] // Assuming `sets` exist in `exercise`, if not, you'll need to adjust\n        }))\n      }))\n    };\n\n    // console.log('Saving program from front end:', programData);\n\n    try {\n      const response = await fetch('http://localhost:9025/api/programs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(programData)\n      });\n\n      if (!response.ok) {\n        throw new Error('Something went wrong with saving the program');\n      }\n\n      // Assuming the backend responds with the created template, you could use it here if needed\n      // const savedTemplate = await response.json();\n    } catch (error) {\n      console.error('Failed to save the program:', error);\n      // Here, you could set an error state and display it to the user if you wish\n    }\n  };\n\n  // Functions to update the state of top-level properties of the program object\n\n  const updateProgramDetails = useCallback(details => {\n    setProgram(prev => ({ ...prev, ...details }));\n  }, []);\n\n  // Function to add a workout to the program\n\n  const addWorkout = useCallback(\n    workout => {\n      console.log(\n        'addWorkout func in context , received workout to add:',\n        workout\n      );\n      const tempId = uuidv4();\n\n      // Find the highest index used in existing workout names\n      const maxIndex = program.workouts.reduce((max, currWorkout) => {\n        const match = currWorkout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      const workoutTitle = `Workout ${maxIndex + 1}`;\n\n      const newWorkout = {\n        ...workout,\n        id: tempId,\n        name: workout.name || workoutTitle\n      };\n      setProgram(prev => ({\n        ...prev,\n        workouts: [...prev.workouts, newWorkout]\n      }));\n      setActiveWorkoutId(newWorkout.id);\n      console.log('Workouts after addWorkout:', newWorkout);\n    },\n    [program.workouts]\n  );\n\n  // Function to update a workout\n\n  const updateWorkout = updatedWorkout => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout =>\n        workout.id === updatedWorkout.id ? updatedWorkout : workout\n      )\n    }));\n  };\n\n  // Function to delete a workout\n\n  const deleteWorkout = useCallback(workoutId => {\n    console.log(`Attempting to delete workout with id: ${workoutId}`);\n    setProgram(prev => {\n      let newActiveWorkoutId = prev.activeWorkoutId;\n      const workoutIndex = prev.workouts.findIndex(\n        workout => workout.id === workoutId\n      );\n\n      // Ensure we have more than one workout to prevent deleting the last one.\n      if (prev.workouts.length <= 1) return prev; // Or handle the error as needed.\n\n      const updatedWorkouts = prev.workouts.filter(\n        workout => workout.id !== workoutId\n      );\n      console.log('Workouts after deletion:', updatedWorkouts);\n\n      // If the deleted workout was the active one, update the activeWorkoutId.\n      if (newActiveWorkoutId === workoutId) {\n        if (workoutIndex === prev.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active.\n          newActiveWorkoutId = updatedWorkouts[workoutIndex - 1].id;\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last).\n          newActiveWorkoutId = updatedWorkouts[Math.max(0, workoutIndex)].id;\n        }\n      }\n\n      // Update the active workout ID in the state.\n      setActiveWorkoutId(newActiveWorkoutId);\n\n      // Return the updated program.\n      return { ...prev, workouts: updatedWorkouts };\n    });\n  }, []);\n\n  // Function to go to the next workout\n\n  const goToNextWorkout = () => {\n    const currentIndex = program.workouts.findIndex(\n      workout => workout.id === activeWorkoutId\n    );\n    const nextIndex = (currentIndex + 1) % program.workouts.length;\n    setActiveWorkoutId(program.workouts[nextIndex].id);\n  };\n\n  // Function to go to the previous workout\n\n  const goToPreviousWorkout = () => {\n    const currentIndex = program.workouts.findIndex(\n      workout => workout.id === activeWorkoutId\n    );\n    const previousIndex =\n      (currentIndex - 1 + program.workouts.length) % program.workouts.length;\n    setActiveWorkoutId(program.workouts[previousIndex].id);\n  };\n\n  // Function to add exercise to a specific workout\n\n  const addExercise = useCallback((workoutId, exercise) => {\n    const tempId = uuidv4();\n\n    setProgram(prev => {\n      const newWorkouts = prev.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          const currentExercises = Array.isArray(workout.exercises)\n            ? workout.exercises\n            : [];\n\n          // Add the tempId to the new exercise object\n          const newExercise = {\n            ...exercise,\n            id: tempId,\n            exerciseCatalogId: exercise.id,\n            isNew: true,\n            sets: [\n              { id: uuidv4(), reps: '', weight: '', order: 1, isNew: true }\n            ]\n          };\n          // console.log('Adding exercise:', newExercise);\n\n          // Determine the next order value for the new exercise\n          const nextOrder =\n            currentExercises.length > 0\n              ? Math.max(...currentExercises.map(ex => ex.order)) + 1\n              : 1;\n\n          return {\n            ...workout,\n            exercises: [\n              ...currentExercises,\n              { ...newExercise, order: nextOrder }\n            ]\n          };\n        }\n        return workout;\n      });\n      return { ...prev, workouts: newWorkouts };\n    });\n  }, []);\n\n  // Function to update an exercise\n\n  const updateExercise = (workoutId, updatedExercise) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          // Found the workout that contains the exercise, now update the exercise\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise =>\n              exercise.catalog_exercise_id ===\n              updatedExercise.catalog_exercise_id\n                ? { ...exercise, ...updatedExercise }\n                : exercise\n            )\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete exercise from  a specific workout\n\n  const deleteExercise = useCallback((workoutId, exerciseId) => {\n    // console.log(\n    //   `Deleting exercise. Workout ID: ${workoutId}, Exercise ID: ${exerciseId}`\n    // );\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // console.log(\n        //   `Before deletion, number of exercises: ${workout.exercises.length}`\n        // );\n\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.filter(\n              exercise => exercise.id !== exerciseId\n            )\n          };\n        }\n\n        return workout;\n      })\n    }));\n  }, []);\n\n  // Function to add sets to a specific exercise\n\n  const addSet = useCallback((workoutId, exerciseId, newSet) => {\n    const tempId = uuidv4();\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // Find the correct workout by its id\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the correct exercise by its catalog ID within the workout\n              if (exercise.id === exerciseId) {\n                // Add the new set with the temporary ID to the exercise's sets array\n                const currentSets = Array.isArray(exercise.sets)\n                  ? exercise.sets\n                  : [];\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const nextOrder =\n                  currentSets.length > 0\n                    ? Math.max(...currentSets.map(set => set.order)) + 1\n                    : 1;\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const updatedSet = {\n                  ...newSet,\n                  id: tempId,\n                  order: nextOrder,\n                  isNew: true\n                };\n\n                return { ...exercise, sets: [...currentSets, updatedSet] };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // useEffect(() => {\n  //   // console.log('Program state updated:', program);\n  // }, [program]); // This effect will run whenever the 'program' state changes\n\n  // Function to update a set\n\n  const updateSet = (workoutId, exerciseId, updatedSet) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                return {\n                  ...exercise,\n                  sets: exercise.sets.map(set => {\n                    // Find the matching set to update\n                    if (set.order === updatedSet.order) {\n                      return { ...set, ...updatedSet };\n                    }\n                    return set;\n                  })\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete a set\n  const deleteSet = (workoutId, exerciseId, setId) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                // Filter out the set to be deleted and renumber the remaining sets\n                const filteredAndRenumberedSets = exercise.sets\n                  .filter(set => set.id !== setId)\n                  .map((set, index) => ({ ...set, order: index + 1 })); // Assuming 'order' needs to be updated\n\n                return {\n                  ...exercise,\n                  sets: filteredAndRenumberedSets\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  return (\n    <ProgramContext.Provider\n      value={{\n        program,\n        saveProgram,\n        updateProgramDetails,\n        addWorkout,\n        updateWorkout,\n        deleteWorkout,\n        goToNextWorkout,\n        goToPreviousWorkout,\n        addExercise,\n        updateExercise,\n        deleteExercise,\n        addSet,\n        updateSet,\n        deleteSet\n      }}\n    >\n      {children}\n    </ProgramContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}