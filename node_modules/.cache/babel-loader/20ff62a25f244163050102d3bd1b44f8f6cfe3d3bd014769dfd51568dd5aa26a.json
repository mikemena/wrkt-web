{"ast":null,"code":"var _jsxFileName = \"/Users/mike/Documents/purple.nosync/pow/web-frontend/src/contexts/programContext.js\",\n  _s = $RefreshSig$();\nimport { createContext, useState, useCallback, useReducer } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Define action types\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ADD_EXERCISE = 'ADD_EXERCISE';\nconst REMOVE_EXERCISE = 'REMOVE_EXERCISE';\n\n// Reducer function\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case ADD_EXERCISE:\n      // Add logic to add exercise to state\n      return {\n        ...state,\n        selectedExercises: [...state.selectedExercises, action.payload]\n      };\n    case REMOVE_EXERCISE:\n      // Add logic to remove exercise from state\n      return {\n        ...state,\n        selectedExercises: state.selectedExercises.filter(exercise => exercise.id !== action.payload.id)\n      };\n    // Handle other action types\n    default:\n      return state;\n  }\n};\n\n// Initial state\nconst initialState = {\n  selectedExercises: []\n};\nexport const ProgramContext = /*#__PURE__*/createContext();\nexport const ProgramProvider = ({\n  children\n}) => {\n  _s();\n  const [activeWorkout, setActiveWorkout] = useState(null);\n  const [program, setProgram] = useState({\n    user_id: 2,\n    // This should be set to the logged in user's ID\n    name: 'Program 1',\n    program_duration: 0,\n    duration_unit: '',\n    days_per_week: 0,\n    main_goal: '',\n    workouts: [{\n      id: uuidv4(),\n      name: 'Workout 1',\n      exercises: [],\n      active: false\n    }]\n  });\n\n  // UseReducer hook\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Functions to update state using reducer actions\n  const addExerciseToSelection = exercise => {\n    dispatch({\n      type: ADD_EXERCISE,\n      payload: exercise\n    });\n  };\n  const removeExerciseFromSelection = exerciseId => {\n    dispatch({\n      type: REMOVE_EXERCISE,\n      payload: {\n        id: exerciseId\n      }\n    });\n  };\n\n  // Initialize the active workout to the first workout in the program\n\n  const updateActiveWorkout = useCallback(workout => {\n    console.log('Updating active workout:', workout);\n    setActiveWorkout(workout);\n  }, []);\n\n  //Save program to the database\n  const saveProgram = async NewProgram => {\n    const programData = {\n      user_id: 2,\n      // Assuming this is static or retrieved from somewhere else\n      name: program.programName,\n      program_duration: program.programDuration,\n      days_per_week: program.daysPerWeek,\n      duration_unit: program.durationUnit,\n      main_goal: program.mainGoal,\n      workouts: program.workouts.map(workout => ({\n        name: workout.name,\n        order: workout.id,\n        // Assuming `id` can serve as `order`\n        exercises: workout.exercises.map(exercise => ({\n          catalog_exercise_id: exercise.catalog_exercise_id,\n          order: exercise.order,\n          // Make sure this exists or determine how to set it\n          sets: exercise.sets || [] // Assuming `sets` exist in `exercise`, if not, you'll need to adjust\n        }))\n      }))\n    };\n\n    // console.log('Saving program from front end:', programData);\n\n    try {\n      const response = await fetch('http://localhost:9025/api/programs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(programData)\n      });\n      if (!response.ok) {\n        throw new Error('Something went wrong with saving the program');\n      }\n\n      // Assuming the backend responds with the created template, you could use it here if needed\n      // const savedTemplate = await response.json();\n    } catch (error) {\n      console.error('Failed to save the program:', error);\n      // Here, you could set an error state and display it to the user if you wish\n    }\n  };\n\n  // Functions to update the state of top-level properties of the program object\n\n  const updateProgramDetails = useCallback(details => {\n    setProgram(prev => ({\n      ...prev,\n      ...details\n    }));\n  }, []);\n\n  // Function to add a workout to the program\n\n  const addWorkout = useCallback(workout => {\n    // console.log('addWorkout function called', workout);\n    // console.log('Current workouts before add:', program.workouts);\n    const tempId = uuidv4();\n\n    // Find the highest index used in existing workout names\n    const maxIndex = program.workouts.reduce((max, currWorkout) => {\n      const match = currWorkout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n      const index = match ? parseInt(match[1], 10) : 0;\n      return Math.max(max, index);\n    }, 0);\n    const workoutTitle = `Workout ${maxIndex + 1}`;\n    const newWorkout = {\n      ...workout,\n      id: tempId,\n      name: workout.name || workoutTitle\n    };\n    setProgram(prev => {\n      const updatedWorkouts = [...prev.workouts, newWorkout];\n      // console.log('Updated workouts after add:', updatedWorkouts);\n      return {\n        ...prev,\n        workouts: updatedWorkouts\n      };\n    });\n\n    // console.log('New activeWorkoutId set:', newWorkout.id);\n    // console.log('Updated workouts after add:', program.workouts);\n    // console.log('Setting activeWorkoutId to:', tempId);\n    setActiveWorkout(newWorkout);\n    // console.log('activeWorkoutId after set:', tempId);\n  }, [setProgram, setActiveWorkout, program.workouts]);\n\n  // Function to update a workout\n\n  const updateWorkout = updatedWorkout => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => workout.id === updatedWorkout.id ? updatedWorkout : workout)\n    }));\n  };\n\n  // Function to delete a workout\n\n  const deleteWorkout = useCallback(workoutId => {\n    setProgram(prev => {\n      const workoutIndex = prev.workouts.findIndex(workout => workout.id === workoutId);\n\n      // Ensure we have more than one workout to prevent deleting the last one.\n      if (prev.workouts.length <= 1) return prev; // Optionally handle the error as needed.\n\n      const updatedWorkouts = prev.workouts.filter(workout => workout.id !== workoutId);\n\n      // Determine the new active workout\n      let newActiveWorkout = null;\n      if (prev.activeWorkout && prev.activeWorkout.id === workoutId) {\n        // If the active workout is the one being deleted, need to find a new active workout\n        if (workoutIndex === prev.workouts.length - 1) {\n          // If it was the last workout, set the previous one as active\n          newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n        } else {\n          // Otherwise, set the next workout as active (or previous if it was the last)\n          newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n        }\n      } else {\n        // If the active workout is not the one being deleted, keep it as is\n        newActiveWorkout = prev.activeWorkout;\n      }\n\n      // Update the active workout in the context\n      setActiveWorkout(newActiveWorkout);\n\n      // Return the updated program with the workout removed\n      return {\n        ...prev,\n        workouts: updatedWorkouts\n      };\n    });\n  }, [setActiveWorkout]);\n\n  // Function to go to the next workout\n\n  const goToNextWorkout = () => {\n    const currentIndex = program.workouts.findIndex(workout => workout.id === activeWorkout.id);\n    const nextIndex = (currentIndex + 1) % program.workouts.length;\n    setActiveWorkout(program.workouts[nextIndex]);\n    console.log('Active workout ID after next:', program.workouts[nextIndex].id);\n  };\n\n  // Function to go to the previous workout\n\n  const goToPreviousWorkout = () => {\n    const currentIndex = program.workouts.findIndex(workout => workout.id === activeWorkout.id);\n    const previousIndex = (currentIndex - 1 + program.workouts.length) % program.workouts.length;\n    setActiveWorkout(program.workouts[previousIndex]);\n    console.log('Active workout ID after previous:', program.workouts[previousIndex].id);\n  };\n\n  // Function to add a new exercise to a workout\n  const addNewExercise = (currentExercises, exercise) => {\n    const newExercise = {\n      ...exercise,\n      id: uuidv4(),\n      // Unique ID for key purposes\n      exerciseCatalogId: exercise.id,\n      isNew: true,\n      sets: [{\n        id: uuidv4(),\n        reps: '',\n        weight: '',\n        order: currentExercises.length + 1,\n        isNew: true\n      }]\n    };\n    console.log('Added new exercise:', newExercise);\n    return newExercise;\n  };\n\n  // Function to create a new exercise\n  function createNewExercise(exercise, currentExercisesLength) {\n    return {\n      id: uuidv4(),\n      exerciseCatalogId: exercise.exerciseCatalogId || exercise.id,\n      name: exercise.name,\n      muscle: exercise.muscle,\n      equipment: exercise.equipment,\n      file_path: exercise.file_path,\n      sets: [{\n        id: uuidv4(),\n        reps: '',\n        weight: '',\n        order: currentExercisesLength + 1,\n        isNew: true\n      }],\n      isNew: true\n    };\n  }\n\n  // Function to add exercises to a specific workout\n  const addExercise = useCallback((workoutId, exercises) => {\n    console.log(`Attempting to add exercises to workout ${workoutId}:`, exercises);\n    setProgram(prev => {\n      const newWorkouts = prev.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          console.log(`Found workout with ID ${workoutId}`);\n          const currentExercises = Array.isArray(workout.exercises) ? workout.exercises : [];\n          console.log(`Current exercises before adding new ones:`, currentExercises);\n          const newExercises = Array.isArray(exercises) ? exercises : [exercises];\n          newExercises.forEach(exercise => {\n            if (!currentExercises.some(ex => ex.exerciseCatalogId === exercise.id)) {\n              const newExercise = createNewExercise(exercise, currentExercises.length);\n              currentExercises.push(newExercise);\n              console.log(`Added new exercise:`, newExercise);\n            } else {\n              console.log(`Exercise with ID ${exercise.id} already exists in the workout`);\n            }\n          });\n          return {\n            ...workout,\n            exercises: currentExercises\n          };\n        }\n        return workout;\n      });\n      console.log(`Updated workouts array after attempting to add exercises:`, newWorkouts);\n      return {\n        ...prev,\n        workouts: newWorkouts\n      };\n    });\n  }, [setProgram]);\n\n  // Function to update an exercise\n\n  const updateExercise = (workoutId, updatedExercise) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          // Found the workout that contains the exercise, now update the exercise\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => exercise.catalog_exercise_id === updatedExercise.catalog_exercise_id ? {\n              ...exercise,\n              ...updatedExercise\n            } : exercise)\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete exercise from  a specific workout\n\n  const deleteExercise = useCallback((workoutId, exerciseId) => {\n    // console.log(\n    //   `Deleting exercise. Workout ID: ${workoutId}, Exercise ID: ${exerciseId}`\n    // );\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // console.log(\n        //   `Before deletion, number of exercises: ${workout.exercises.length}`\n        // );\n\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.filter(exercise => exercise.id !== exerciseId)\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // Function to add sets to a specific exercise\n\n  const addSet = useCallback((workoutId, exerciseId, newSet) => {\n    const tempId = uuidv4();\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // Find the correct workout by its id\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the correct exercise by its catalog ID within the workout\n              if (exercise.id === exerciseId) {\n                // Add the new set with the temporary ID to the exercise's sets array\n                const currentSets = Array.isArray(exercise.sets) ? exercise.sets : [];\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const nextOrder = currentSets.length > 0 ? Math.max(...currentSets.map(set => set.order)) + 1 : 1;\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const updatedSet = {\n                  ...newSet,\n                  id: tempId,\n                  order: nextOrder,\n                  isNew: true\n                };\n                return {\n                  ...exercise,\n                  sets: [...currentSets, updatedSet]\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // useEffect(() => {\n  //   // console.log('Program state updated:', program);\n  // }, [program]); // This effect will run whenever the 'program' state changes\n\n  // Function to update a set\n\n  const updateSet = (workoutId, exerciseId, updatedSet) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                return {\n                  ...exercise,\n                  sets: exercise.sets.map(set => {\n                    // Find the matching set to update\n                    if (set.order === updatedSet.order) {\n                      return {\n                        ...set,\n                        ...updatedSet\n                      };\n                    }\n                    return set;\n                  })\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete a set\n  const deleteSet = (workoutId, exerciseId, setId) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                // Filter out the set to be deleted and renumber the remaining sets\n                const filteredAndRenumberedSets = exercise.sets.filter(set => set.id !== setId).map((set, index) => ({\n                  ...set,\n                  order: index + 1\n                })); // Assuming 'order' needs to be updated\n\n                return {\n                  ...exercise,\n                  sets: filteredAndRenumberedSets\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n  return /*#__PURE__*/_jsxDEV(ProgramContext.Provider, {\n    value: {\n      program,\n      saveProgram,\n      updateProgramDetails,\n      addWorkout,\n      updateWorkout,\n      activeWorkout,\n      updateActiveWorkout,\n      deleteWorkout,\n      goToNextWorkout,\n      goToPreviousWorkout,\n      addExercise,\n      addNewExercise,\n      updateExercise,\n      createNewExercise,\n      deleteExercise,\n      addSet,\n      updateSet,\n      deleteSet,\n      // Expose state and dispatch functions\n      selectedExercises: state.selectedExercises,\n      addExerciseToSelection,\n      removeExerciseFromSelection\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 500,\n    columnNumber: 5\n  }, this);\n};\n_s(ProgramProvider, \"wjSdyQ/ztzWfOtzs51YH12QzVBw=\");\n_c = ProgramProvider;\nvar _c;\n$RefreshReg$(_c, \"ProgramProvider\");","map":{"version":3,"names":["createContext","useState","useCallback","useReducer","v4","uuidv4","jsxDEV","_jsxDEV","ADD_EXERCISE","REMOVE_EXERCISE","reducer","state","action","type","selectedExercises","payload","filter","exercise","id","initialState","ProgramContext","ProgramProvider","children","_s","activeWorkout","setActiveWorkout","program","setProgram","user_id","name","program_duration","duration_unit","days_per_week","main_goal","workouts","exercises","active","dispatch","addExerciseToSelection","removeExerciseFromSelection","exerciseId","updateActiveWorkout","workout","console","log","saveProgram","NewProgram","programData","programName","programDuration","daysPerWeek","durationUnit","mainGoal","map","order","catalog_exercise_id","sets","response","fetch","method","headers","body","JSON","stringify","ok","Error","error","updateProgramDetails","details","prev","addWorkout","tempId","maxIndex","reduce","max","currWorkout","match","index","parseInt","Math","workoutTitle","newWorkout","updatedWorkouts","updateWorkout","updatedWorkout","prevProgram","deleteWorkout","workoutId","workoutIndex","findIndex","length","newActiveWorkout","goToNextWorkout","currentIndex","nextIndex","goToPreviousWorkout","previousIndex","addNewExercise","currentExercises","newExercise","exerciseCatalogId","isNew","reps","weight","createNewExercise","currentExercisesLength","muscle","equipment","file_path","addExercise","newWorkouts","Array","isArray","newExercises","forEach","some","ex","push","updateExercise","updatedExercise","deleteExercise","addSet","newSet","currentSets","nextOrder","set","updatedSet","updateSet","deleteSet","setId","filteredAndRenumberedSets","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/mike/Documents/purple.nosync/pow/web-frontend/src/contexts/programContext.js"],"sourcesContent":["import { createContext, useState, useCallback, useReducer } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Define action types\nconst ADD_EXERCISE = 'ADD_EXERCISE';\nconst REMOVE_EXERCISE = 'REMOVE_EXERCISE';\n\n// Reducer function\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case ADD_EXERCISE:\n      // Add logic to add exercise to state\n      return {\n        ...state,\n        selectedExercises: [...state.selectedExercises, action.payload]\n      };\n    case REMOVE_EXERCISE:\n      // Add logic to remove exercise from state\n      return {\n        ...state,\n        selectedExercises: state.selectedExercises.filter(\n          exercise => exercise.id !== action.payload.id\n        )\n      };\n    // Handle other action types\n    default:\n      return state;\n  }\n};\n\n// Initial state\nconst initialState = {\n  selectedExercises: []\n};\n\nexport const ProgramContext = createContext();\n\nexport const ProgramProvider = ({ children }) => {\n  const [activeWorkout, setActiveWorkout] = useState(null);\n  const [program, setProgram] = useState({\n    user_id: 2, // This should be set to the logged in user's ID\n    name: 'Program 1',\n    program_duration: 0,\n    duration_unit: '',\n    days_per_week: 0,\n    main_goal: '',\n    workouts: [\n      { id: uuidv4(), name: 'Workout 1', exercises: [], active: false }\n    ]\n  });\n\n  // UseReducer hook\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Functions to update state using reducer actions\n  const addExerciseToSelection = exercise => {\n    dispatch({ type: ADD_EXERCISE, payload: exercise });\n  };\n\n  const removeExerciseFromSelection = exerciseId => {\n    dispatch({ type: REMOVE_EXERCISE, payload: { id: exerciseId } });\n  };\n\n  // Initialize the active workout to the first workout in the program\n\n  const updateActiveWorkout = useCallback(workout => {\n    console.log('Updating active workout:', workout);\n    setActiveWorkout(workout);\n  }, []);\n\n  //Save program to the database\n  const saveProgram = async NewProgram => {\n    const programData = {\n      user_id: 2, // Assuming this is static or retrieved from somewhere else\n      name: program.programName,\n      program_duration: program.programDuration,\n      days_per_week: program.daysPerWeek,\n      duration_unit: program.durationUnit,\n      main_goal: program.mainGoal,\n      workouts: program.workouts.map(workout => ({\n        name: workout.name,\n        order: workout.id, // Assuming `id` can serve as `order`\n        exercises: workout.exercises.map(exercise => ({\n          catalog_exercise_id: exercise.catalog_exercise_id,\n          order: exercise.order, // Make sure this exists or determine how to set it\n          sets: exercise.sets || [] // Assuming `sets` exist in `exercise`, if not, you'll need to adjust\n        }))\n      }))\n    };\n\n    // console.log('Saving program from front end:', programData);\n\n    try {\n      const response = await fetch('http://localhost:9025/api/programs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(programData)\n      });\n\n      if (!response.ok) {\n        throw new Error('Something went wrong with saving the program');\n      }\n\n      // Assuming the backend responds with the created template, you could use it here if needed\n      // const savedTemplate = await response.json();\n    } catch (error) {\n      console.error('Failed to save the program:', error);\n      // Here, you could set an error state and display it to the user if you wish\n    }\n  };\n\n  // Functions to update the state of top-level properties of the program object\n\n  const updateProgramDetails = useCallback(details => {\n    setProgram(prev => ({ ...prev, ...details }));\n  }, []);\n\n  // Function to add a workout to the program\n\n  const addWorkout = useCallback(\n    workout => {\n      // console.log('addWorkout function called', workout);\n      // console.log('Current workouts before add:', program.workouts);\n      const tempId = uuidv4();\n\n      // Find the highest index used in existing workout names\n      const maxIndex = program.workouts.reduce((max, currWorkout) => {\n        const match = currWorkout.name.match(/Workout (\\d+)/); // Assuming the format \"Workout 1\", \"Workout 2\", etc.\n        const index = match ? parseInt(match[1], 10) : 0;\n        return Math.max(max, index);\n      }, 0);\n\n      const workoutTitle = `Workout ${maxIndex + 1}`;\n\n      const newWorkout = {\n        ...workout,\n        id: tempId,\n        name: workout.name || workoutTitle\n      };\n      setProgram(prev => {\n        const updatedWorkouts = [...prev.workouts, newWorkout];\n        // console.log('Updated workouts after add:', updatedWorkouts);\n        return { ...prev, workouts: updatedWorkouts };\n      });\n\n      // console.log('New activeWorkoutId set:', newWorkout.id);\n      // console.log('Updated workouts after add:', program.workouts);\n      // console.log('Setting activeWorkoutId to:', tempId);\n      setActiveWorkout(newWorkout);\n      // console.log('activeWorkoutId after set:', tempId);\n    },\n    [setProgram, setActiveWorkout, program.workouts]\n  );\n\n  // Function to update a workout\n\n  const updateWorkout = updatedWorkout => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout =>\n        workout.id === updatedWorkout.id ? updatedWorkout : workout\n      )\n    }));\n  };\n\n  // Function to delete a workout\n\n  const deleteWorkout = useCallback(\n    workoutId => {\n      setProgram(prev => {\n        const workoutIndex = prev.workouts.findIndex(\n          workout => workout.id === workoutId\n        );\n\n        // Ensure we have more than one workout to prevent deleting the last one.\n        if (prev.workouts.length <= 1) return prev; // Optionally handle the error as needed.\n\n        const updatedWorkouts = prev.workouts.filter(\n          workout => workout.id !== workoutId\n        );\n\n        // Determine the new active workout\n        let newActiveWorkout = null;\n        if (prev.activeWorkout && prev.activeWorkout.id === workoutId) {\n          // If the active workout is the one being deleted, need to find a new active workout\n          if (workoutIndex === prev.workouts.length - 1) {\n            // If it was the last workout, set the previous one as active\n            newActiveWorkout = updatedWorkouts[workoutIndex - 1];\n          } else {\n            // Otherwise, set the next workout as active (or previous if it was the last)\n            newActiveWorkout = updatedWorkouts[Math.max(0, workoutIndex)];\n          }\n        } else {\n          // If the active workout is not the one being deleted, keep it as is\n          newActiveWorkout = prev.activeWorkout;\n        }\n\n        // Update the active workout in the context\n        setActiveWorkout(newActiveWorkout);\n\n        // Return the updated program with the workout removed\n        return { ...prev, workouts: updatedWorkouts };\n      });\n    },\n    [setActiveWorkout]\n  );\n\n  // Function to go to the next workout\n\n  const goToNextWorkout = () => {\n    const currentIndex = program.workouts.findIndex(\n      workout => workout.id === activeWorkout.id\n    );\n    const nextIndex = (currentIndex + 1) % program.workouts.length;\n    setActiveWorkout(program.workouts[nextIndex]);\n    console.log(\n      'Active workout ID after next:',\n      program.workouts[nextIndex].id\n    );\n  };\n\n  // Function to go to the previous workout\n\n  const goToPreviousWorkout = () => {\n    const currentIndex = program.workouts.findIndex(\n      workout => workout.id === activeWorkout.id\n    );\n    const previousIndex =\n      (currentIndex - 1 + program.workouts.length) % program.workouts.length;\n    setActiveWorkout(program.workouts[previousIndex]);\n    console.log(\n      'Active workout ID after previous:',\n      program.workouts[previousIndex].id\n    );\n  };\n\n  // Function to add a new exercise to a workout\n  const addNewExercise = (currentExercises, exercise) => {\n    const newExercise = {\n      ...exercise,\n      id: uuidv4(), // Unique ID for key purposes\n      exerciseCatalogId: exercise.id,\n      isNew: true,\n      sets: [\n        {\n          id: uuidv4(),\n          reps: '',\n          weight: '',\n          order: currentExercises.length + 1,\n          isNew: true\n        }\n      ]\n    };\n    console.log('Added new exercise:', newExercise);\n    return newExercise;\n  };\n\n  // Function to create a new exercise\n  function createNewExercise(exercise, currentExercisesLength) {\n    return {\n      id: uuidv4(),\n      exerciseCatalogId: exercise.exerciseCatalogId || exercise.id,\n      name: exercise.name,\n      muscle: exercise.muscle,\n      equipment: exercise.equipment,\n      file_path: exercise.file_path,\n      sets: [\n        {\n          id: uuidv4(),\n          reps: '',\n          weight: '',\n          order: currentExercisesLength + 1,\n          isNew: true\n        }\n      ],\n      isNew: true\n    };\n  }\n\n  // Function to add exercises to a specific workout\n  const addExercise = useCallback(\n    (workoutId, exercises) => {\n      console.log(\n        `Attempting to add exercises to workout ${workoutId}:`,\n        exercises\n      );\n      setProgram(prev => {\n        const newWorkouts = prev.workouts.map(workout => {\n          if (workout.id === workoutId) {\n            console.log(`Found workout with ID ${workoutId}`);\n            const currentExercises = Array.isArray(workout.exercises)\n              ? workout.exercises\n              : [];\n            console.log(\n              `Current exercises before adding new ones:`,\n              currentExercises\n            );\n            const newExercises = Array.isArray(exercises)\n              ? exercises\n              : [exercises];\n            newExercises.forEach(exercise => {\n              if (\n                !currentExercises.some(\n                  ex => ex.exerciseCatalogId === exercise.id\n                )\n              ) {\n                const newExercise = createNewExercise(\n                  exercise,\n                  currentExercises.length\n                );\n                currentExercises.push(newExercise);\n                console.log(`Added new exercise:`, newExercise);\n              } else {\n                console.log(\n                  `Exercise with ID ${exercise.id} already exists in the workout`\n                );\n              }\n            });\n            return { ...workout, exercises: currentExercises };\n          }\n          return workout;\n        });\n        console.log(\n          `Updated workouts array after attempting to add exercises:`,\n          newWorkouts\n        );\n        return { ...prev, workouts: newWorkouts };\n      });\n    },\n    [setProgram]\n  );\n\n  // Function to update an exercise\n\n  const updateExercise = (workoutId, updatedExercise) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        if (workout.id === workoutId) {\n          // Found the workout that contains the exercise, now update the exercise\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise =>\n              exercise.catalog_exercise_id ===\n              updatedExercise.catalog_exercise_id\n                ? { ...exercise, ...updatedExercise }\n                : exercise\n            )\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete exercise from  a specific workout\n\n  const deleteExercise = useCallback((workoutId, exerciseId) => {\n    // console.log(\n    //   `Deleting exercise. Workout ID: ${workoutId}, Exercise ID: ${exerciseId}`\n    // );\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // console.log(\n        //   `Before deletion, number of exercises: ${workout.exercises.length}`\n        // );\n\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.filter(\n              exercise => exercise.id !== exerciseId\n            )\n          };\n        }\n\n        return workout;\n      })\n    }));\n  }, []);\n\n  // Function to add sets to a specific exercise\n\n  const addSet = useCallback((workoutId, exerciseId, newSet) => {\n    const tempId = uuidv4();\n\n    setProgram(prev => ({\n      ...prev,\n      workouts: prev.workouts.map(workout => {\n        // Find the correct workout by its id\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the correct exercise by its catalog ID within the workout\n              if (exercise.id === exerciseId) {\n                // Add the new set with the temporary ID to the exercise's sets array\n                const currentSets = Array.isArray(exercise.sets)\n                  ? exercise.sets\n                  : [];\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const nextOrder =\n                  currentSets.length > 0\n                    ? Math.max(...currentSets.map(set => set.order)) + 1\n                    : 1;\n\n                // Add the new set with the temporary ID to the exercise's sets array\n                const updatedSet = {\n                  ...newSet,\n                  id: tempId,\n                  order: nextOrder,\n                  isNew: true\n                };\n\n                return { ...exercise, sets: [...currentSets, updatedSet] };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  }, []);\n\n  // useEffect(() => {\n  //   // console.log('Program state updated:', program);\n  // }, [program]); // This effect will run whenever the 'program' state changes\n\n  // Function to update a set\n\n  const updateSet = (workoutId, exerciseId, updatedSet) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                return {\n                  ...exercise,\n                  sets: exercise.sets.map(set => {\n                    // Find the matching set to update\n                    if (set.order === updatedSet.order) {\n                      return { ...set, ...updatedSet };\n                    }\n                    return set;\n                  })\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  // Function to delete a set\n  const deleteSet = (workoutId, exerciseId, setId) => {\n    setProgram(prevProgram => ({\n      ...prevProgram,\n      workouts: prevProgram.workouts.map(workout => {\n        // Find the matching workout\n        if (workout.id === workoutId) {\n          return {\n            ...workout,\n            exercises: workout.exercises.map(exercise => {\n              // Find the matching exercise\n              if (exercise.id === exerciseId) {\n                // Filter out the set to be deleted and renumber the remaining sets\n                const filteredAndRenumberedSets = exercise.sets\n                  .filter(set => set.id !== setId)\n                  .map((set, index) => ({ ...set, order: index + 1 })); // Assuming 'order' needs to be updated\n\n                return {\n                  ...exercise,\n                  sets: filteredAndRenumberedSets\n                };\n              }\n              return exercise;\n            })\n          };\n        }\n        return workout;\n      })\n    }));\n  };\n\n  return (\n    <ProgramContext.Provider\n      value={{\n        program,\n        saveProgram,\n        updateProgramDetails,\n        addWorkout,\n        updateWorkout,\n        activeWorkout,\n        updateActiveWorkout,\n        deleteWorkout,\n        goToNextWorkout,\n        goToPreviousWorkout,\n        addExercise,\n        addNewExercise,\n        updateExercise,\n        createNewExercise,\n        deleteExercise,\n        addSet,\n        updateSet,\n        deleteSet,\n        // Expose state and dispatch functions\n        selectedExercises: state.selectedExercises,\n        addExerciseToSelection,\n        removeExerciseFromSelection\n      }}\n    >\n      {children}\n    </ProgramContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}